#   Copyright 2008 Sam Chapin
#
#   This file is part of Gospel.
#
#   Gospel is free software: you can redistribute it and/or modify
#   it under the terms of version 3 of the GNU General Public License
#   as published by the Free Software Foundation.
#
#   Gospel is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with Gospel.  If not, see <http://www.gnu.org/licenses/>.

&do
&raise:

# A primitive must not do anything that will prevent GCC's sibling call optimization, including taking a
# pointer to anything in its own automatic memory.

@null null
$serialized string(temp(), "<null>")
!identity
  normalReturn;
!interpret
  normalReturn;
!print
  fputs("<null>", stdout);
  fflush(stdout);
  normalReturn;
@internals null
# Used by the core to implement some of the interpreter's behaviour. Not meant for user code.
!vectorLiteral
  int c = vectorLength(evaluated(threadContinuation(thread))) - 1;
  vector v = makeVector(edenRoot(thread), c);
  while (c--) setIdx(v, c, arg(c));
  valueReturn(vectorObject(edenRoot(thread), v));
!methodBody
  int l = vectorLength(evaluated(threadContinuation(thread)));
  valueReturn(l == 1 ? oNull : arg(l - 2));
@interpreter object
!include:
  // Not threadsafe, should only be accessed through the channel in the lobby.
  // TODO: Check that filename is really a string?
  obj a = waitFor(arg(0));
  if (!isString(a)) raise(thread, eStringExpected);
  *filenameToInclude = a;
  valueReturn(*promiseOfInclusion = newPromise(edenRoot(thread)));
@object null
!setProto:
  obj p = arg(0);
  setProto(edenRoot(thread), target, p);
  valueReturn(p);
!== equals
  if (target == waitFor(arg(0))) valueReturn(oTrue);
  valueReturn(oFalse);
!send:
  continuation c = origin(threadContinuation(thread));
  tailcall(doNext,
           setSubexpressionContinuation(thread,
                                        c,
                                        env(c),
                                        dynamicEnv(c),
                                        target,
                                        waitFor(arg(0)),
                                        emptyVector));
!respondsTo:
  obj a = waitFor(arg(0)), t = target;
  for (int i = 0; i < slotCount(t); i++) if (slotName(t, i) == a) valueReturn(oTrue);
  valueReturn(oFalse);
!selectors
  valueReturn(vectorObject(edenRoot(thread), slotNameVector(edenRoot(thread), target)));
!proto
  valueReturn(proto(target));
!channel
  valueReturn(newChannel(edenRoot(thread), target));
!identity
  normalReturn;
!addSlot:as:
  valueReturn(addSlot(edenRoot(thread), target, waitFor(arg(0)), arg(1)));
!setSlot:to:
  void **slot = deepLookup(target, waitFor(arg(0)));
  if (!slot) raise(thread, eSettingNonexistantSlot);
  valueReturn(*slot = arg(1));
!contentsOfSlot:
  void **slot = deepLookup(target, waitFor(arg(0)));
  if (!slot) raise(thread, eGettingNonexistantSlot);
  valueReturn(*slot);
!new
  obj o = slotlessObject(edenRoot(thread), target, hiddenEntity(target));
  setVectorType(o, vectorType(target));
  valueReturn(o);
@vector object
!ofLength:containing:
  int l = safeIntegerValue(waitFor(arg(0)));
  if (l < 0) raise(thread, eNegativeVectorLength);
  obj o = arg(1);
  vector v = makeVector(edenRoot(thread), l);
  while (l--) setIdx(v, l, o);
  valueReturn(vectorObject(edenRoot(thread), v));
!length
  valueReturn(integer(edenRoot(thread), vectorLength(hiddenEntity(target))));
!at:put:ifAbsent:
  int i = safeIntegerValue(waitFor(arg(0)));
  obj v = hiddenEntity(target);
  if (i < 0) i = vectorLength(v) + i;
  if (i < 0 || i >= vectorLength(v)) {
    continuation c = origin(threadContinuation(thread));
    tailcall(doNext,
             setSubexpressionContinuation(thread, c, env(c), dynamicEnv(c), arg(2), sDo, emptyVector));
  }
  valueReturn(setIdx(v, i, arg(1)));
!at:ifAbsent:
  int i = safeIntegerValue(waitFor(arg(0)));
  obj v = hiddenEntity(target);
  if (i < 0) i = vectorLength(v) + i;
  if (i < 0 || i >= vectorLength(v)) {
    continuation c = origin(threadContinuation(thread));
    tailcall(doNext,
             setSubexpressionContinuation(thread, c, env(c), dynamicEnv(c), arg(1), sDo, emptyVector));
  }
  valueReturn(idx(v, i));
@primitive object newAtomVector(temp(), 1, prototypePrimitiveHiddenValue)
@string object newAtomVector(temp(), 1, 0)
!serialized
  // FIXME: This should probably convert e.g. newlines to "\n".
  vector eden = makeVector(edenRoot(thread), 2);
  obj quote = string(edenIdx(eden, 0), "\""); // TODO: Create this string once, at startup.
  valueReturn(appendStrings(edenIdx(eden, 1), quote, appendStrings(edenIdx(eden, 1), target, quote)));
!++ appending:
  obj a = waitFor(arg(0));
  if (!isString(target) || !isString(a)) raise(thread, eStringExpected);
  valueReturn(appendStrings(edenRoot(thread), target, waitFor(arg(0))));
!print
  if (!isString(target)) raise(thread, eStringExpected);
  fputs(stringData(target), stdout);
  fflush(stdout);
  normalReturn;
@symbol object newAtomVector(temp(), 1, 0)
!serialized
  // TODO: Create the dollarsign string once, at startup.
  valueReturn(appendStrings(edenRoot(thread), string(edenRoot(thread), "$"), target));
@closure object newVector(temp(), 3, oNull, emptyVector, newVector(temp(), 1, oClosure))
!environment
  valueReturn(closureEnv(target));
@code object
!interpret
  continuation c = threadContinuation(thread);
  obj o = continuationTarget(c);
  vector *live = edenRoot(thread);
  tailcall(doNext,
           setContinuation(thread,
                           newContinuation(live,
                                           origin(c),
                                           codeSelector(o),
                                           emptyVector,
                                           prefix(live, codeTarget(o) ?: env(c), codeArgs(o)),
                                           env(c),
                                           dynamicEnv(c))));
@promiseCode object
!interpret
  vector *life = edenRoot(thread);
  promise p = newPromise(life);
  continuation c = threadContinuation(thread);
  newThread(life,
            p,
            env(c),
            dynamicEnv(c),
            hiddenEntity(continuationTarget(c)),
            sIdentity,
            emptyVector);
  valueReturn(p);
@arrowCode object
!from:
  vector eden = makeVector(edenRoot(thread), 2);
  promise p = newPromise(edenIdx(eden, 0));
  continuation c = threadContinuation(thread);
  newThread(edenIdx(eden, 1),
            p,
            env(c),
            dynamicEnv(c),
            oInternals,
            sMethodBody,
            newVector(edenIdx(eden, 1),
                      2,
                      message(edenIdx(eden, 1), arg(0), sIdentity, emptyVector),
                      hiddenEntity(target)));
  valueReturn(p);
@block object
!interpret
  continuation c = threadContinuation(thread);
  obj o = continuationTarget(c);
  valueReturn(newClosure(edenRoot(thread), env(c), blockParams(o), blockBody(o)));
@integer object newAtomVector(temp(), 1, 0)
!serialized
  valueReturn(integerAsString(edenRoot(thread), safeIntegerValue(target)));
!== equals
  if (safeIntegerValue(target) == safeIntegerValue(waitFor(arg(0)))) normalReturn;
  valueReturn(oFalse);
!< isLessThan
  if (safeIntegerValue(target) < safeIntegerValue(waitFor(arg(0)))) normalReturn;
  valueReturn(oFalse);
!> isGreaterThan
  if (safeIntegerValue(target) > safeIntegerValue(waitFor(arg(0)))) normalReturn;
  valueReturn(oFalse);
!- minus:
  valueReturn(integer(edenRoot(thread),
              safeIntegerValue(target) - safeIntegerValue(waitFor(arg(0)))));
!+ plus:
  valueReturn(integer(edenRoot(thread),
                      safeIntegerValue(target) + safeIntegerValue(waitFor(arg(0)))));
!secondsDelay
  int i = safeIntegerValue(target);
  while (i) i = sleep(i);
  valueReturn(target);
@byteVector object
!length
  // TODO: Typechecking?
  valueReturn(integer(edenRoot(thread), vectorLength(hiddenEntity(target)) / sizeof(int)));
@file object
# This could be made more abstract by having methods obtain the target's file descriptor through
# a message ("$posixFileDescriptor"?) instead of assuming that it is the target's hidden atom.
!close
  if (close(safeIntegerValue(target))) raise(thread, eClosingFile);
  normalReturn;
!readBytes:
  vector *live = edenRoot(thread), living = makeVector(live, 3);
  int length = safeIntegerValue(waitFor(arg(0)));
  vector buffer = makeAtomVector(idxPointer(living, 0), (length + sizeof(int) - 1) / sizeof(int));
  int count = read(safeIntegerValue(target), buffer->data, length);
  vector result = makeAtomVector(idxPointer(living, 2), (count + sizeof(int) - 1) / sizeof(int));
  memcpy(result->data, buffer->data, count);
  valueReturn(slotlessObject(live, oByteVector, result));
@socket file
!posixFileDescriptor
  valueReturn(integer(edenRoot(thread), (int)hiddenAtom(target)));
!new
  int s = socket(PF_INET, SOCK_STREAM, 0);
  if (s == -1) raise(thread, eOpeningSocket);
  valueReturn(setProto(edenRoot(thread), integer(edenRoot(thread), s), oSocket));
!bind:
  if (bindSocket(safeIntegerValue(target), safeIntegerValue(waitFor(arg(0)))))
    raise(thread, eBindingSocket);
  normalReturn;
!listenWithBacklog:
  if (listen((int)hiddenAtom(target), safeIntegerValue(waitFor(arg(0)))))
    raise(thread, eListeningOnSocket);
  normalReturn;
!accept
  int newSocket = acceptSocket(safeIntegerValue(target));
  if (newSocket == -1) raise(thread, eAcceptingSocketConnection);
  life eden = edenRoot(thread);
  valueReturn(setProto(eden, integer(eden, newSocket), oSocket));
!read:
  int length = safeIntegerValue(waitFor(arg(0)));
  vector *live = edenRoot(thread);
  obj string = slotlessObject(live, oString, makeAtomVector(live, length));
  if (recv(safeIntegerValue(target), vectorData(hiddenEntity(string)), length, 0) == -1)
    raise(thread, eReadingFromSocket);
  valueReturn(string);
@true object
@false object
@exception object
~stringExpected Non-string encountered where string expected.
~stackFrameExpected Something other than a stack frame encountered where stack frame expected.
~integerExpected Non-integer encountered where integer expected.
~negativeVectorLength Attempted to create a vector with negative length.
~messageNotUnderstood Message not understood.
~readingFromSocket Error while reading from a socket.
~openingSocket Error while opening a socket.
~bindingSocket Error while binding a socket.
~listeningOnSocket Error while beginning to listen on a socket.
~acceptingSocketConnection Error while accepting a connection on a socket.
~closingFile Error while closing a file.
~outOfBounds Out-of-bounds array access.
~badReturnDepth Too many carets in return statement.
~topLevelRecursion Attempted to recurse at the top level.
~settingNonexistantSlot Attempted to set a nonexistant slot.
~gettingNonexistantSlot Attempted to access a nonexistant slot.
~missingArgument Too few arguments to primitive function.
@lobby object oInternals
!return:atDepth:
  obj frame = target;
  for (int i = safeIntegerValue(waitFor(arg(1)));;) {
    if (frame == oLobby) raise(thread, eBadReturnDepth);
    if (!i--) break;
    frame = proto(frame);
  }
  obj v = *edenRoot(thread) = arg(0); // Because it might be orphaned when we change continuations.
  setContinuation(thread, safeStackFrameContinuation(frame));
  valueReturn(v);
!return
  if (target == oLobby) raise(thread, eBadReturnDepth);
  setContinuation(thread, safeStackFrameContinuation(target));
  valueReturn(oNull);
!return:
  if (target == oLobby) raise(thread, eBadReturnDepth);
  obj v = *edenRoot(thread) = arg(0); // Because it might be orphaned when we change continuations.
  setContinuation(thread, safeStackFrameContinuation(target));
  valueReturn(v);
!thisContext
  normalReturn;
!recurse
  if (target == oLobby) raise(thread, eTopLevelRecursion);
  tailcall(doNext, setContinuation(thread, safeStackFrameContinuation(target)));
!abortToREPL
  tailcall(returnToREPL, thread);
!self
  normalReturn;
!abort
  tailcall(returnToREPL, thread);
!end
  killThreadData(thread);
  // Permit a C subroutine return, thus killing the current thread.
$true
$false
$object
$closure
$integer
$null
$lobby
$file
$socket
$byteVector
$code
$promiseCode
$arrowCode
$block
$primitive
$string
$symbol
$interpreter newChannel(temp(), oInterpreter)
$exception
$vector
!dynamicContext
  valueReturn(dynamicEnv(threadContinuation(thread)));
!collectGarbage
  forbidGC();
  collectGarbage();
  permitGC();
  normalReturn;
!exit
  exit(0);
@dynamicEnvironment object
