#   Copyright Â© 2008, 2009 Sam Chapin
#
#   This file is part of Gospel.
#
#   Gospel is free software: you can redistribute it and/or modify
#   it under the terms of version 3 of the GNU General Public License
#   as published by the Free Software Foundation.
#
#   Gospel is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with Gospel.  If not, see <http://www.gnu.org/licenses/>.

&do
&self
&currentMessageTarget

# If a primitive must do anything that will prevent GCC's sibling call optimization, such as taking
# a pointer to its own automatic memory, then declare it ?foo rather than !foo.

@deadEnd deadEnd
  raise(currentThread, eMessageNotUnderstood);
@null deadEnd
!serialized
  valueReturn(string("<null>"));
!raise
  die("Attempted to raise nil as an exception.");
!handler
  die("Exception handler requested where none established.");
!identity
  normalReturn;
!interpret
  normalReturn;
!interpretInScope:inEnvironment:
  normalReturn;
!print
  fputs("<null>", stdout);
  fflush(stdout);
  normalReturn;
@defaultMessageTarget object
!interpret
  valueReturn(env(threadContinuation(currentThread)));
@internals null
# Used by the core to implement some of the interpreter's behaviour. Not meant for user code.
# The hidden data field contains the symbol table. The default initialization, to NULL, is correct:
#  If we also explicitly initialized it to NULL here, we would be overwriting the symbols of the builtins.
!vectorLiteral
  int c = vectorLength(evaluated(threadContinuation(currentThread))) - 1;
  vector v = makeVector(c);
  while (c--) setIdx(v, c, arg(c));
  valueReturn(vectorObject(v));
!methodBody
  int l = vectorLength(evaluated(threadContinuation(currentThread)));
  valueReturn(l == 1 ? oNull : arg(l - 2));
!cascading:
  // TODO: This happens when the lefmost message to the right of a cascade is parenthesized. This is another indication that we need to replace the "messageBody" message with a new AST object.
  raise(currentThread, eSyntaxError);
@object null oInternals
!do:
  obj b = waitFor(arg(0));
  if (!isBlock(b)) raise(currentThread, eBlockExpected);
  obj m = blockMethod(b);
  if (methodArity(m)) raise(currentThread, eBadArity);
  vector c = threadContinuation(currentThread);
  setSubexpressionContinuation(currentThread,
                               origin(c),
                               target, // We don't construct a new lexical contour.
                               newDynamicScope(c),
                               oInternals,
                               sMethodBody,
                               methodBody(m));
  gotoNext;
!self
  normalReturn;
# We stash a pointer to oInternals here to lend it oObjects's immunity to garbage collection.
# It would perhaps make more sense to give oInternals the immunity, and let oObject borrow it,
# but future changes to the interpreter may eliminate the need for oInternals.
!return:atDepth:
  obj frame = target;
  for (int i = safeIntegerValue(waitFor(arg(1)));;) {
    if (frame == oObject) raise(currentThread, eBadReturnDepth);
    if (!i--) break;
    frame = proto(frame);
  }
  obj v = shelter(currentThread, arg(0)); // Because it might be orphaned when we change continuations.
  setContinuation(currentThread, safeStackFrameContinuation(frame));
  valueReturn(v);
!return
  if (target == oObject) raise(currentThread, eBadReturnDepth);
  setContinuation(currentThread, safeStackFrameContinuation(target));
  valueReturn(oNull);
!return:
  if (target == oObject) raise(currentThread, eBadReturnDepth);
  obj v = shelter(currentThread, arg(0)); // Because it might be orphaned when we change continuations.
  setContinuation(currentThread, safeStackFrameContinuation(target));
  valueReturn(v);
!thisContext
  normalReturn;
!recurse
  if (target == oObject) raise(currentThread, eTopLevelRecursion);
  setContinuation(currentThread, safeStackFrameContinuation(target));
  gotoNext;
!end
  killThreadData(currentThread);
  // Permit a C subroutine return, thus killing the current thread.
$parser
# TODO: Put the next entry in an "interpreter" namespace when objgen supports it:
$defaultMessageTarget
$true
$false
$object
$integer
$null
$code
$promiseCode
$arrowCode
$block
$primitive
$string
$symbol
$exception
$vector
$POSIX
$canon oNamespaceCanon
$namespace
!dynamicContext
  valueReturn(dynamicEnv(threadContinuation(currentThread)));
!collectGarbage
  forbidGC();
  collectGarbage();
  permitGC();
  normalReturn;
!exit
  exit(0);
# "Lobby" stuff ends here.
!interpretInScope:inEnvironment:
  setContinuation(currentThread,
                  newContinuation(origin(threadContinuation(currentThread)),
                                  sInterpret,
                                  newVector(1, target),
                                  emptyVector, // There should be no reason for anyone to examine this.
                                  waitFor(arg(0)),
                                  waitFor(arg(1))));
  gotoNext;
!evaluate:in:
  setSubexpressionContinuation(currentThread,
                               origin(threadContinuation(currentThread)),
                               target,
                               waitFor(arg(1)),
                               parseString(safeStringValue(waitFor(arg(0)))),
                               sIdentity,
                               emptyVector);
  gotoNext;
!include:in:
  obj filename = waitFor(arg(0));
  if (!isString(filename)) raise(currentThread, eStringExpected);
  FILE *f = fopen(stringData(filename), "r");
  if (!f) raise(currentThread, eInclusion);
  void *lastValue = loadStream(f, target, waitFor(arg(1)));
  if (lastValue == eSyntaxError) raise(currentThread, eSyntaxError);
  valueReturn(lastValue);
!setProto:
  obj p = waitFor(arg(0));
  setProto(target, p);
  valueReturn(p);
!== equals
  if (target == waitFor(arg(0))) valueReturn(oTrue);
  valueReturn(oFalse);
!send:
  continuation c = origin(threadContinuation(currentThread));
  setSubexpressionContinuation(currentThread,
                               c,
                               env(c),
                               dynamicEnv(c),
                               target,
                               waitFor(arg(0)),
                               emptyVector);
  gotoNext;
!localSelectors
  obj o = target;
  int n = slotCount(o);
  vector v = makeVector(n);
  while (n--) setIdx(v, n, slotName(o, n));
  valueReturn(vectorObject(v));
!proto
  valueReturn(proto(target));
!channel
  valueReturn(newChannel(target));
!identity
  normalReturn;
!addSlot:as:
  valueReturn(addSlot(target, waitFor(arg(0)), arg(1), threadContinuation(currentThread)));
!setSlot:to:
  void **slot = deepLookup(target, waitFor(arg(0)), threadContinuation(currentThread));
  if (!slot) raise(currentThread, eSettingNonexistantSlot);
  valueReturn(*slot = arg(1));
!new
  obj o = slotlessObject(target, hiddenEntity(target));
  setVectorType(o, vectorType(target));
  valueReturn(o);
@namespace object
@namespaceCanon namespace
$serialized string("<canon!>")
@vector object
!== equals
  obj v1 = target, v2 = waitFor(arg(0));
  valueReturn(vectorLength(safeVector(v1)) || vectorLength(safeVector(v2)) ? v1 == v2 ? v1 : oFalse : v1);
!++ appending
  valueReturn(vectorObject(vectorAppend(safeVector(target), safeVector(waitFor(arg(0))))));
!ofLength:containing:
  int l = safeIntegerValue(waitFor(arg(0)));
  if (l < 0) raise(currentThread, eNegativeVectorLength);
  obj o = arg(1);
  vector v = makeVector(l);
  while (l--) setIdx(v, l, o);
  valueReturn(vectorObject(v));
!length
  valueReturn(integer(vectorLength(hiddenEntity(target))));
!at:put:ifAbsent:
  int i = safeIntegerValue(waitFor(arg(0)));
  obj v = hiddenEntity(target);
  if (i < 0) i = vectorLength(v) + i;
  if (i < 0 || i >= vectorLength(v)) {
    continuation c = origin(threadContinuation(currentThread));
    setSubexpressionContinuation(currentThread,
                                 c,
                                 env(c),
                                 dynamicEnv(c),
                                 arg(2),
                                 sAppliedTo_,
                                 newVector(1, vectorObject(emptyVector)));
    gotoNext;
  }
  valueReturn(setIdx(v, i, arg(1)));
!at:ifAbsent:
  int i = safeIntegerValue(waitFor(arg(0)));
  obj v = hiddenEntity(target);
  if (i < 0) i = vectorLength(v) + i;
  if (i < 0 || i >= vectorLength(v)) {
    continuation c = origin(threadContinuation(currentThread));
    setSubexpressionContinuation(currentThread,
                                 c,
                                 env(c),
                                 dynamicEnv(c),
                                 arg(1),
                                 sAppliedTo_,
                                 newVector(1, vectorObject(emptyVector)));
    gotoNext;
  }
  valueReturn(idx(v, i));
@primitive object newAtomVector(1, prototypePrimitiveHiddenValue)
@string object newAtomVector(1, 0)
!parse
  valueReturn(parseString(safeStringValue(target)));
!serialized
  // FIXME: This should probably convert e.g. newlines to "\n".
  obj quote = string("\""); // TODO: Create this string once, at startup.
  valueReturn(appendStrings(quote, appendStrings(target, quote)));
!++ appending:
  obj a = waitFor(arg(0));
  if (!isString(target) || !isString(a)) raise(currentThread, eStringExpected);
  valueReturn(appendStrings(target, waitFor(arg(0))));
!print
  if (!isString(target)) raise(currentThread, eStringExpected);
  fputs(stringData(target), stdout);
  fflush(stdout);
  normalReturn;
@symbol object newAtomVector(1, 0)
!serialized
  // TODO: Create the dollarsign string once, at startup.
  valueReturn(appendStrings(string("$"), target));
@blockLiteral object
# This could inherit from oMethod, but we're avoiding that because we might want to make oMethod and
# oPrimitive more magical than they are now.
!interpret
  valueReturn(block(env(threadContinuation(currentThread)), blockLiteralMethod(target)));
@block object newVector(2, oNull, oMethod)
~blockExpected Block expected.
!bind:
  obj t = target;
  if (!isBlock(t)) raise(currentThread, eBlockExpected);
  setBlockEnv(t, waitFor(arg(0)));
  normalReturn;
!appliedTo:
  obj t = target;
  if (!isBlock(t)) raise(currentThread, eBlockExpected);
  vector args = safeVector(waitFor(arg(0)));
  obj m = blockMethod(t);
  if (vectorLength(args) != methodArity(m)) raise(currentThread, eBadArity);
  setMethodContinuation(threadContinuation(currentThread), blockEnv(t), prefix(t, args), m);
  gotoNext;
@method object newVector(2, newVector(1, oNull), newVector(1, oMethod))
@quote object
!interpret
  valueReturn(unquote(target));
@code object
!cascading:
  obj m = target;
  valueReturn(message(call(quote(codeTarget(m)), sCascading_, newVector(1, quote(arg(0)))),
                      codeSelector(m),
                      codeArgs(m)));  
!interpret
  continuation c = threadContinuation(currentThread);
  setContinuation(currentThread,
                  newContinuation(origin(c),
                                  codeSelector(target),
                                  emptyVector,
                                  prefix(codeTarget(target) ?: env(c), codeArgs(target)),
                                  env(c),
                                  dynamicEnv(c)));
  gotoNext;
@promiseCode code
!interpret
  promise p = newPromise();
  continuation c = threadContinuation(currentThread);
  obj m = target;  
  newThread(p, env(c), dynamicEnv(c), codeTarget(m), codeSelector(m), codeArgs(m));
  valueReturn(p);
@arrowCode object
!from:
  promise p = newPromise();
  continuation c = threadContinuation(currentThread);
  newThread(p,
            env(c),
            dynamicEnv(c),
            oInternals,
            sMethodBody,
            newVector(2, message(arg(0), sIdentity, emptyVector), hiddenEntity(target)));
  valueReturn(p);
@endOfFile object
# Returned by the parser when it encounters an end-of-file.
!interpret
  exit(0);
@parser object newAtomVector(1, beginParsing(stdin))
~syntaxError Syntax error.
!read
  // FIXME: This is not typesafe.
  obj parserOutput = parse(hiddenAtom(target));
  if (parserOutput == eSyntaxError) raise(currentThread, eSyntaxError);
  valueReturn(parserOutput);
@integer object newAtomVector(1, 0)
?serialized
  char buffer[12]; // FIXME: Assumes signed 32-bit fixnums.
  sprintf(buffer, "%d", safeIntegerValue(target));
  valueReturn(string(buffer));
!== equals
  if (safeIntegerValue(target) == safeIntegerValue(waitFor(arg(0)))) normalReturn;
  valueReturn(oFalse);
!< isLessThan
  if (safeIntegerValue(target) < safeIntegerValue(waitFor(arg(0)))) normalReturn;
  valueReturn(oFalse);
!> isGreaterThan
  if (safeIntegerValue(target) > safeIntegerValue(waitFor(arg(0)))) normalReturn;
  valueReturn(oFalse);
!- minus:
  valueReturn(integer(safeIntegerValue(target) - safeIntegerValue(waitFor(arg(0)))));
!+ plus:
  valueReturn(integer(safeIntegerValue(target) + safeIntegerValue(waitFor(arg(0)))));
!secondsDelay
  int i = safeIntegerValue(target);
  while (i) i = sleep(i);
  valueReturn(target);
@POSIX null
~POSIX Error during a POSIX system call.
$stdin integer(0)
!errno
  valueReturn(integer(errno));
!close:
  if (close(safeIntegerValue(arg(0)))) raise(currentThread, ePOSIX);
  normalReturn;
!read:from:
  int count = safeIntegerValue(waitFor(arg(0)));
  vector s = makeAtomVector(CELLS_REQUIRED_FOR_BYTES(count + 1));
  char *b = vectorData(s);
  ssize_t i = read(safeIntegerValue(waitFor(arg(1))), b, count);
  if (i == -1) raise(currentThread, ePOSIX);
  b[i] = 0;
  valueReturn(slotlessObject(oString, s));
!write:to:
  char *s = safeStringValue(waitFor(arg(0)));
  ssize_t i = write(safeIntegerValue(waitFor(arg(1))), s, strlen(s));
  if (i == -1) raise(currentThread, ePOSIX);
  valueReturn(integer(i));
?bindInternetSocket:to:
  struct sockaddr_in s;
  memset(&s, 0, sizeof(struct sockaddr_in));
  s.sin_family = AF_INET;
  s.sin_port = htons(safeIntegerValue(waitFor(arg(1))));
  s.sin_addr.s_addr = htonl(INADDR_ANY);
  if (bind(safeIntegerValue(waitFor(arg(0))),
           (struct sockaddr *)&s, (socklen_t)sizeof(struct sockaddr_in)))
    raise(currentThread, ePOSIX);
  normalReturn;
!TCPSocket
  int s = socket(PF_INET, SOCK_STREAM, 0);
  if (s == -1) raise(currentThread, ePOSIX);
  valueReturn(integer(s));
!listenOn:withMaximumBacklog:
  if (listen(safeIntegerValue(waitFor(arg(0))), safeIntegerValue(waitFor(arg(1)))))
    raise(currentThread, ePOSIX);
  normalReturn;
?acceptOn:
  struct sockaddr socketParameters;
  socklen_t socketParametersSize = sizeof(struct sockaddr);
  int newSocket = accept(safeIntegerValue(waitFor(arg(0))), &socketParameters, &socketParametersSize);
  if (newSocket == -1) raise(currentThread, ePOSIX);
  valueReturn(integer(newSocket));
!shutdown:
  if (shutdown(safeIntegerValue(waitFor(arg(0))), SHUT_RDWR)) raise(currentThread, ePOSIX);
  normalReturn;
@true object
@false object
@exception object
~inclusion Error while attempting to open a file for inclusion.
~badArity Wrong number of arguments.
~stringExpected String expected.
~stackFrameExpected Stack frame expected.
~primitiveExpected Primitive expected.
~vectorExpected Vector expected.
~integerExpected Integer expected.
~negativeVectorLength Attempted to create a vector with negative length.
~messageNotUnderstood Message not understood.
~outOfBounds Out-of-bounds array access.
~badReturnDepth Too many carets in return statement.
~topLevelRecursion Attempted to recurse at the top level.
~settingNonexistantSlot Attempted to set a nonexistant slot.
~gettingNonexistantSlot Attempted to access a nonexistant slot.
~missingArgument Too few arguments to primitive function.
@dynamicEnvironment object newVector(1, oNamespaceCanon)
!setNamespaces:
  obj v = waitFor(arg(0));
  if (!isVectorObject(v)) raise(currentThread, eVectorExpected);
  setHiddenData(target, vectorObjectVector(v));
  normalReturn;
!namespaces
  valueReturn(vectorObject(hiddenEntity(target)));


