#!/usr/bin/perl

#   Copyright 2008 Sam Chapin
#
#   This file is part of Gospel.
#
#   Gospel is free software: you can redistribute it and/or modify
#   it under the terms of version 3 of the GNU General Public License
#   as published by the Free Software Foundation.
#
#   Gospel is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with Gospel.  If not, see <http://www.gnu.org/licenses/>.


# Convert a GoSPeL identifier to a C identifier.
sub cname {
  my $name = ucfirst shift;
  $name =~ s/:/_/g;
  return $name;
}

$id = qr/[[:alnum:]]*[[:alpha:]][[:alnum:]]*/;
while (<>) {
  if    (/^(\#.*| *)$/            ) {                                                            }
  elsif (/^&((?:$id:?)+)/         ) { push @symbols, $1;                                         }
  elsif (/^@($id) ($id) ?(.*)$/   ) { $parent{$currentObject = $1} = $2;
                                      $objects{$currentObject} = [];
                                      $hidden{$currentObject} = $3;                              }
  elsif (/^~($id) ([^\n]*)$/      ) { $exceptions{$currentObject}{$1} = $2;                      }
  elsif (/^!($id(?::(?:$id:)*)?)/ ) { $methods{$currentMethod = $1} = $1; $callable = 0;         }
  elsif (/^!([^ ]+) ($id)/        ) { $methods{$currentMethod = $2} = $1; $callable = 0;         }
  elsif (/^\?($id(?::(?:$id:)*)?)/) { $callableMethods{$currentMethod = $1} = $1; $callable = 1; }
  elsif (/^\?([^ ]+) ($id)/       ) { $callableMethods{$currentMethod = $2} = $1; $callable = 1; }
  elsif (/^\$($id) ([^\n]+)/      ) { push @{$constants{$currentObject}}, [$1, $2];              }
  elsif (/^\$($id)/               ) { push @{$constants{$currentObject}}, [$1, "o" . cname($1)]; }
  else                              { $objects{$currentObject}[$callable]{$currentMethod} .= $_; }
}

sub slotCount {
  $_ = shift;
  return (keys %{$objects{$_}[0]})
       + (keys %{$objects{$_}[1]})
       + @{$constants{$_}}
       + (keys %{$exceptions{$_}});
}

open HEADER, ">objects.h" or die("ObjGen couldn't write objects.h");
open SOURCE, ">objects.c" or die("ObjGen couldn't write objects.c");

print HEADER "#ifndef OBJECTS_H\n#define OBJECTS_H\n\nobj ",
      (join "\n  , ",
           (map { "o" . cname $_ } keys %objects),
           (map { "s" . cname $_ } @symbols, keys(%methods), keys %callableMethods),
           (map { join "\n  , ", map { "s" . cname $_->[0] } @$_ } values %constants),
           (map { join "\n  , ", map { "e" . cname $_ } keys %$_ } values %exceptions)),
      ";\n\n#endif\n";

foreach $object (keys %objects) {
  print SOURCE "void m", cname($object), cname($_), "(vector thread) {\n",
                  $objects{$object}[0]{$_},
               "}\n"
    foreach (keys %{$objects{$object}[0]});
  foreach (keys %{$objects{$object}[1]}) {
    my $id = cname($object) . cname($_);
    print SOURCE "void *b$id(vector) __attribute__ ((noinline));\n",
                 "void m$id(vector thread) { gotoNext(b$id(thread)); }\n";
  }
  print SOURCE "\n";
}
print SOURCE "#undef tailcall\n",
             "#undef gotoNext\n",
             "#define tailcall(f, ...) do { f(__VA_ARGS__); terminateThread(thread); } while (0)\n",
             "#define gotoNext(t) return (t)\n";
foreach $object (keys %objects) {
  print SOURCE "void *b", cname($object), cname($_), "(vector thread) {\n",
                  $objects{$object}[1]{$_},
               "}\n"
   foreach (keys %{$objects{$object}[1]});
  print SOURCE "\n";
}
print SOURCE "#undef tailcall\n",
             "#undef gotoNext\n",
             "#define tailcall(f, ...) do { f(__VA_ARGS__); return; } while (0)\n",
             "#define gotoNext(t) tailcall(doNext, (t))\n";


print SOURCE "void initializeObjects() {\n";
# Objects need to be initialized first, since the symbols and exceptions that come next will refer
# to the values of object identifiers for their prototypes.
print SOURCE "  o", cname($_), " = newObject(temp(), NIL, emptyVector, emptyVector, NIL);\n"
 foreach(keys %objects);
print SOURCE "\n";
foreach $objectExceptions (values %exceptions) {
  print SOURCE "  e", cname($_), " = string(temp(), \"$objectExceptions->{$_}\");\n"
   foreach(keys %$objectExceptions);
}
foreach (keys %methods) {
  print SOURCE "  s", cname($_), " = symbol(temp(), \"$methods{$_}\");\n";
}
foreach (keys %callableMethods) {
  print SOURCE "  s", cname($_), " = symbol(temp(), \"$callableMethods{$_}\");\n";
}
foreach (@symbols) {
  print SOURCE "  s", cname($_), " = symbol(temp(), \"$_\");\n";
}
foreach $objectConstants (values %constants) {
  print SOURCE "  s", cname($_->[0]), " = symbol(temp(), \"$_->[0]\");\n"
   foreach (@$objectConstants);
}

foreach $object (keys %objects) {
  print SOURCE "\n  setHiddenData(o", cname($object), ", ", $hidden{$object}, ");"
   if ($hidden{$object} !~ /^ *$/);
  print SOURCE "\n  setProto(temp(), o", cname($object), ", o", cname($parent{$object}), ");"
   if ($parent{$object});

  print SOURCE "\n  setSlotNames(temp(), o", cname($object), ", newVector(temp(), ", slotCount $object;
  print SOURCE "\n  , s", cname($_)
   foreach ((keys %{$objects{$object}[0]}), keys %{$objects{$object}[1]});
  print SOURCE "\n  , s", cname($_->[0])
   foreach (@{$constants{$object}});
  print SOURCE "\n  , symbol(temp(), \"$_\")"
   foreach (keys %{$exceptions{$object}});
  print SOURCE "));";

  print SOURCE "\n  setSlotValues(o", cname($object), ", newVector(temp(), ", slotCount $object;
  print SOURCE "\n  , primitive(temp(), m", cname($object), cname($_), ")"
   foreach ((keys %{$objects{$object}[0]}), keys %{$objects{$object}[1]});
  print SOURCE "\n  , $_->[1]"
   foreach (@{$constants{$object}});
  print SOURCE "\n  , e", cname($_)
   foreach (keys %{$exceptions{$object}});
  print SOURCE "));\n";
}
print SOURCE "}\n";
