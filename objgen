#!/usr/bin/perl

#   Copyright 2008 Sam Chapin
#
#   This file is part of Gospel.
#
#   Gospel is free software: you can redistribute it and/or modify
#   it under the terms of version 3 of the GNU General Public License
#   as published by the Free Software Foundation.
#
#   Gospel is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with Gospel.  If not, see <http://www.gnu.org/licenses/>.


# Convert a GoSPeL identifier to a C identifier.
sub cname {
  my $name = ucfirst shift;
  $name =~ s/:/_/g;
  return $name;
}

$id = qr/[[:alnum:]]*[[:alpha:]][[:alnum:]]*/;
while (<>) {
  if    (/^(\#.*| *)$/           ) {                                                            }
  elsif (/^&((?:$id:?)+)/        ) { push @symbols, $1;                                         }
  elsif (/^@($id) ($id)(.*)$/    ) { $parent{$currentObject = $1} = $2;
                                     $objects{$currentObject} = {};
                                     $hidden{$currentObject} = $3;                              }
  elsif (/^~($id) ([^\n]*)$/     ) { $exceptions{$currentObject}{$1} = $2;                      }
  elsif (/^!($id(?::(?:$id:)*)?)/) { $methods{$currentMethod = $1} = $1;                        }
  elsif (/^!([^ ]+) ($id)/       ) { $methods{$currentMethod = $2} = $1;                        }
  elsif (/^\$($id) ([^\n]+)/     ) { push @{$constants{$currentObject}}, [$1, $2];              }
  elsif (/^\$($id)/              ) { push @{$constants{$currentObject}}, [$1, "o" . cname($1)]; }
  else                             { $objects{$currentObject}{$currentMethod} .= $_;            }
}

open HEADER, ">objects.h" or die("ObjGen couldn't write objects.h");
open SOURCE, ">objects.c" or die("ObjGen couldn't write objects.c");

print HEADER "obj ",
      (join "\n  , ",
           (map { "o" . cname $_ } keys %objects),
           (map { "s" . cname $_ } @symbols, keys %methods),
           (map { join "\n  , ", map { "s" . cname $_->[0] } @$_ } values %constants),
           (map { join "\n  , ", map { "e" . cname $_ } keys %$_ } values %exceptions)),
      ";\n";

foreach $object (keys %objects) {
  foreach (keys %{$objects{$object}}) {
    print SOURCE "void m", cname($object), cname($_), "(vector thread) {\n", $objects{$object}{$_}, "}\n";
  }
  print SOURCE "\n";
}

print SOURCE "void initializeObjects() {\n";
# Objects need to be initialized first, since the symbols and exceptions that come next will refer
# to the values of object identifiers for their prototypes.
print SOURCE "  o", cname($_), " = newObject(temp(), NIL, emptyVector, emptyVector, NIL);\n"
 foreach(keys %objects);
print SOURCE "\n";
foreach $objectExceptions (values %exceptions) {
  print SOURCE "  e", cname($_), " = string(temp(), \"$objectExceptions->{$_}\");\n"
   foreach(keys %$objectExceptions);
}
foreach (keys %methods) {
  print SOURCE "  s", cname($_), " = symbol(temp(), \"$methods{$_}\");\n";
}
foreach (@symbols) {
  print SOURCE "  s", cname($_), " = symbol(temp(), \"$_\");\n";
}
foreach $objectConstants (values %constants) {
  print SOURCE "  s", cname($_->[0]), " = symbol(temp(), \"$_->[0]\");\n"
   foreach (@$objectConstants);
}

foreach $object (keys %objects) {
  print SOURCE "\n  setHiddenData(o", cname($object), ", ", $hidden{$object}, ");"
   if ($hidden{$object} !~ /^ *$/);
  print SOURCE "\n  setProto(temp(), o", cname($object), ", o", cname($parent{$object}), ");"
   if ($parent{$object});

  print SOURCE "\n  setSlotNames(temp(), o", cname($object), ", newVector(temp(), ", scalar(keys %{$objects{$object}}) + scalar(@{$constants{$object}}) + scalar(keys %{$exceptions{$object}});
  print SOURCE "\n  , s", cname($_)
   foreach (keys %{$objects{$object}});
  print SOURCE "\n  , s", cname($_->[0])
   foreach (@{$constants{$object}});
  print SOURCE "\n  , symbol(temp(), \"$_\")"
   foreach (keys %{$exceptions{$object}});
  print SOURCE "));";

  print SOURCE "\n  setSlotValues(o", cname($object), ", newVector(temp(), ", scalar(keys %{$objects{$object}}) + scalar(@{$constants{$object}}) + scalar(keys %{$exceptions{$object}});
  print SOURCE "\n  , primitive(temp(), m", cname($object), cname($_), ")"
   foreach (keys %{$objects{$object}});
  print SOURCE "\n  , $_->[1]"
   foreach (@{$constants{$object}});
  print SOURCE "\n  , e", cname($_)
   foreach (keys %{$exceptions{$object}});
  print SOURCE "));\n";
}
print SOURCE "}\n";
