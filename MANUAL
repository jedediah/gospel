Copyright Â© 2008, 2009 Sam Chapin


Gospel is a prototype-based, object-oriented language with special support for
concurrency. It resembles Io somewhat, and JavaScript somewhat less.


SEMANTICS
---------

An object in Gospel is a set of zero or more "slots", each having a name
(usually a "symbol", see below) and contents. Each object has exactly one
"prototype" object.

When a message is sent to an object, its slots are checked for one that matches
the message selector. If none do, that object's prototype is checked (and then
the prototype's prototype, et cetera), and when a match is found the contents of
the slot are evaluated: If the slot contains code (a block or a primitive
function) it is executed, and otherwise the contents are returned. (This is the
default dispatch behaviour. The <null> object behaves differently, and in a
future release of Gospel it will be possible to give any object a custom
"dispatch method".)

Any message can be sent asynchronously, meaning that the execution of the
message occurs in a new thread. The sender moves on to evaluating its next
subexpression, with a "promise" in place of the return value of the message:
Attempting to send a message to the promise, or pass it as an argument to a
primitive that must inspect its value, will block until the promise is
"fulfilled" by its own thread. The "arrow" notation (see below) can be used to
indicate that a given expression should not be evaluated until after the promise
of another expression has been fulfilled.

Gospel provides a simple mutual exclusion mechanism called a "channel", which
appears as a reference to an object. All messages sent via a given channel are
executed one at a time.


SYNTAX
------

The two most important syntactic elements are literals and messages.

The following literal types are supported in the current version:
- Integers (fixnums in the current implementation, bignum support coming soon):
  > 42
- Strings (currently ASCII, unicode coming soon):
  > "foo"
- Symbols (all instances of a given spelling refer to the same object in
memory):
  > $foo
- Vectors (the commas have minimum precedence):
  > [$foo, x + 42, $bar]
- Blocks (lexical closures: the parameter list with vertical bar is optional)
  > { x | x + 1 }

Messages are as follows, in descending order of precedence:
- Unary (taking no arguments):
  > 4 squared
  => 16
- Binary (selector consisting of non-alphanumeric characters, taking one
argument), e.g.:
  > 4 + 1
  => 5
- Keyword (selector consisting of one or more colon-delimited keywords, one per
argument), e.g.:
  > file open: "foo.txt" for: $reading
  => <file 0xdeadbeef>
  (The symbol for the selector of this message would be "$open:for:".)

A keyword message with only one argument can optionally be written with a colon
prefix, e.g. "4 :plus: 2", in which case it is parsed with the precedence of a
binary message.

End-of-statement is indicated with either a newline or a period, and has lower
precedence than anything but the commas in a vector literal. Multiple statements
normally occur inside a block, but can also appear in parentheses as an
expression whose value is the value of the last statement.

Whenever the target of a message is not specified, it is sent to the object
that represents the current lexical context. When a block literal is evaluated
it captures a reference to this object, and when execution enters a block it
creates a new object (to contain its parameters) whose proto is the captured
context.

A binary or keyword message written without a target has a special priority
when on the right of a binary or keyword message, e.g. "foo: bar: x baz: y" is
parsed as "foo: (bar: x baz: y)" and "1 + bar: x" as "1 + (bar: x)".

An asynchronous message is indicated by prefixing the selector (or the first
keyword, in the case of a keyword message) with '@', e.g. "mySocket @read: 10
bytes". Arrows are written as e.g. "a -> b", indicating that expression "b"
should be evaluated in a new thread at whatever time the promise of "a" is
fulfilled, while in the meantime execution continues to the next subexpression
after the arrow, with the value of the arrow expression being the value of "b".
Arrows have precedence immediately above end-of-statement.

There is a special syntax, with lower precedence than keyword messages, for
creating and assigning slots. "foo x = 42" creates a slot called $x, on the
object resulting from the expression "foo", with an initial value of 42. "foo x
:= 42" looks for an existing slot called $x in the object resulting from "foo",
and then in the prototype of that object, et cetera, and sets the contents of
the first one it encounters to 42. These operators are syntactic sugar,
equivalent to "foo addSlot: $x as: 42" and "foo setSlot: $x to: 42",
respectively.

There is also a special syntax for defining methods (i.e. slots containing
blocks). The following pairs are almost equivalent:

foo { 42 }                 foo = { 42 }
foo: x { x + 42 }          foo: = { x | x + 42 }
foo: x bar: y { x + y }    foo:bar: = { x y | x + y }
foo { 42 } bar             foo = { 42 } bar
foo: \bar: { bar: 42 }     foo: = { bar: | bar: 42 }

The only semantic difference between a method declaration and a block literal
is that within the body of a declaration, the target of the message to which the
method is responding can be obtained with the $self message. A block literal
will generally not be interested in the target of the message to which it is
responding (this often being the lexical context object of a method into which
the block was passed as an argument), but if necessary it can be obtained with
the $currentMessageTarget message.

When execution reaches the end of a block, it returns with the value of the
last statement. There is a syntax for returning early:
> { { ^ "this will be returned" } do. "this will not be printed" print } do
=> "this will be returned"

A single caret actually returns not from the current block, but from the block
lexically enclosing it. This is because early returns from methods almost always
occur inside the block arguments to messages such as "$if:else:". Writing two
carets causes a return from the next-outermost block, and so forth: They are
syntactic sugar for "return: (value) atDepth: (n)" where (n) is the number of
carets in the return statement.

A semicolon indicates a "cascade": The message to the right of the semicolon is
sent to the same target as the message immediately to the left. "(socket new)
write: first; write: second" sends both $write: messages to the same socket
object.

Future versions of this manual will include documentation of "the canon",
Gospel's (currently very limited) core library.
